ステップ1: 部分問題の定義（状態の定義）
まず、解きたい「大きな問題」を、どのような「小さな部分問題」の集まりとして表現できるかを定義します。これがDPの状態になります。
何を変数とするか？ 問題の制約や目標（例: 長さ、重さ、個数、インデックス）に基づいて変数を定義します。
例:
ナップサック問題: DP[i][j] = 品物 i までを考慮し、重さの総和が j 以下での価値の最大値。
最長共通部分列問題: DP[i][j] = 文字列Aの i 文字目までと、文字列Bの j 文字目までの最長共通部分列の長さ。
良い部分問題の定義が、良い漸化式への第一歩となります。
ステップ2: 部分問題間の関係性の特定
定義した部分問題 DP[現在の状態] が、どのように「一つ前の（より小さな）」状態 DP[過去の状態] から計算できるかを考えます。
最後の操作に着目する: 「最終的に何が起こったか？」あるいは「最後の要素をどう扱うか？」に注目すると、関係性が見えてきやすいです。
例 (フィボナッチ数列): F(n) は F(n-1) と F(n-2) の和で計算できます。最後の操作は「F(n-1) に F(n-2) を足すこと」です。
ステップ3: 漸化式の構築
ステップ2で見つけた関係性を数式（漸化式）として表現します。
これは通常、いくつかの選択肢の中から最適なもの（最大値、最小値、総和など）を選ぶ形になります。
例 (ナップサック問題):
品物 i を「選ばない」場合: DP[i-1][j]
品物 i を「選ぶ」場合: DP[i-1][j - weight[i]] + value[i]
漸化式: DP[i][j] = max(DP[i-1][j], DP[i-1][j - weight[i]] + value[i])
ステップ4: ベースケース（初期条件）の設定
漸化式の計算をどこから始めるかを定義します。これは再帰の「終了条件」に相当します。
DP[0][j] や DP[i][0] の値は何か？
例 (ナップサック問題): DP[0][j] (品物0まで、つまり何も選んでいない状態) は全て 0 になります。
具体的なアプローチのヒント：「最後の要素を見る」
多くのDP問題では、「最後の要素（または最後のステップ）をどのように決定するか」を考えることが有効です。
線形DP (数列、文字列):
「最後の要素を使うか、使わないか？」
「最後から1番目、2番目、...の要素のどれと組み合わせるか？」
グリッド/グラフDP:
「今のマスに到達するために、どの隣接マスから来たか？」
まとめ
漸化式の構築はパターン認識と練習が不可欠です。
状態 DP[... ] を明確に定義する。
最後のステップに着目し、選択肢を洗い出す。
選択肢の中から最適なものを選ぶ操作（max, min, sum など）で数式化する。
ベースケースを設定する。
多くの問題を解くことで、異なる問題パターンに対応する漸化式の形が見えてくるようになります。